((data:lambda (fail succeed)
   (system:out "
               Lindsey is incredible!
	       " fail succeed))
  (data:lambda () (system:err "Error!" system:exit system:exit))
  system:exit)

((data:lambda (open-reader)
   (data:des args system:exit (data:lambda (binary args)
     (data:des args system:exit (data:lambda (source-file args)
       (open-reader
         (data:lambda (cont)
           (system:scan-file source-file system:exit cont)
         (data:lambda (cursor next next-symbol step-in step-out close)
           (next system-exit (data:lambda (source)
             (system:eval source system:exit system:exit)))))))))))

  ; open-reader
  (data:lambda (scanner cont)
    ((data:lambda (skip-whitespace advance-if-eq scan-name)
       ((data:lambda (reader) (reader reader '(0 0) scanner cont))
         ;reader
         (data:lambda (reader cursor scanner cont) (cont (data:lambda (cont) (cont

           ; state
           cursor scanner

           ; next
           (data:lambda (error cont) (...))

           ; next-symbol
           (data:lambda (error fail cont)
             ((data:lambda (next-symbol) (next-symbol next-symbol data:lookup-symbol error fail cont))
               (data:lambda (next-symbol lookup-symbol error fail cont)
                 (skip-whitespace scanner (data:lambda (scanner)
                   (scan-name scanner fail (data:lambda (scanner name)
                     (advance-if-eq scanner ':'
                       (data:lambda ()
                         (data:lookup-symbol name (data:lambda (symbol)
                           (reader reader cursor###+1 scanner cont))))
                       (data:lambda (scanner)
                         (data:lookup-namespace name (data:lambda (lookup-symbol)
                           (next-symbol next-symbol lookup-symbol error error cont))))))))))))

           ; step-in
           (data:lambda (error fail cont)
             (skip-whitespace scanner (data:lambda (scanner)
               (advance-if-eq scanner '(' fail (data:lambda (scanner)
                 (reader reader ###cursor+1 scanner cont))))))

           ; step-out
           (data:lambda (error fail cont) ())))))))))

    

    ; skip-whitespace
    (data:lambda (scanner cont)
      (scanner (data:lambda (position buffer advance advance-if advance-while close)
        (advance-while text:whitespace? (data:lambda (scanner length)
          (scanner (data:lambda (position buffer advance advance-if advance-while close)
            (buffer (data:lambda (position take discard)
              (discard cont))))))))))

    ; advance-if-eq
    (data:lambda (scanner character fail cont)
      (scanner (data:lambda (position buffer advance advance-if advance-while close)
        (advance-if (data:lambda (c f t) (eq character c f t)) fail (data:lambda (scanner character) (cont scanner))))))

    ; scan-name
    (data:lambda (scanner fail cont)
      (scanner (data:lambda (position buffer advance advance-if advance-while close)
        (advance-if text:alphanumeric fail (data:lambda (scanner character)
          (scanner (data:lambda (position buffer advance advance-if advance-while close)
            (advance-while text:alphanumeric (data:lambda (scanner length)
              (scanner (data:lambda (position buffer advance advance-if advance-while close)
                (buffer (data:lambda (position take discard)
                  (take cont))))))))))))))
      



Bootstrap responsibilities:

- reader (inc. macros)

- text (unicode)

- numerics

- content hashing (we want to do this early because it's a good target for intrinsics)






; The bootstrap file is read and evaluated by the runtime before anything else happens.
; This means that the platform must include some functionality, i.e. to read and evaluate
; Ohvu source files, before that functionality has actually been defined in Ohvu.
;
; The responsibility of the bootstrap file is to reimplement all of that functionality
; other than those parts which are given as primitives, and also provide a hook to load
; and evaluate further source files. This makes the implementation almost completely
; self-hosted.
;
; The bootstrap file is evaluated in a lexical context where symbols of primitive
; functions and special forms are bound to themselves, and program:args is bound to a
; list of program argument strings.
;
; Implementing a reader means also implementing string utilities, a scanner, etc.
; Maybe the responsibility shouldn't solely be on this single bootstrap file. Maybe the
; built-in reader should be used to read in a *set of* bootstrap files.
;
; We have no built-in module system, so how do we link together these bootstrap files?
; How do we define a module system early? Including limiting the scanner to fail on
; reading non-exported symbols of other packages. We need the macro system first.
;
; We don't need a full module system to load other bootstrap files because we can trust
; them.





; OOTB Ohvu simply reads and evaluates the first s expression it finds.
; Since we're using CPS, each expression gets to decide what the runtime does next.
; For instance they can call ``continue`` to read and evaluate the next instruction.
; Or ``exit`` to stop reading and evaluating.
;
; Is there any state shared between expressions evaluated in this manner? Perhaps
; the "continue" function takes a map of bindings.
;
; But each evaluating expression has access to the reader and scanner, making it trivial
; to take over reading and evaluating the rest of the file.



; Can we have 'export' and 'import' predefined?




; Custom resolvers for symbols from different namespaces?

; For instance we could have the macros `define` and `lookup`

(hash:define context 'is-even (lambda (x cont)
  (des x (lambda (a b) (is-odd b (lambda (odd) (not odd cont))))
         (lambda () (cont true)))) continue)

(hash:define context 'is-odd (lambda (x cont)
  (des x (lambda (a b) (is-even b (lambda (even) (not even cont))))
         (lambda () (cont true)))) continue)

; each passes a modified context to continue

(hash:lookup context 'is-even continue)
; passes to continue the following:
  hash:|reference is-even a4wtgh897q35htobarve89f4wjfe|

(hash:lookup context 'is-odd continue)
; passes to continue the following:
  hash:|reference is-odd 3q5yj0hm56m0qw4g0ffackg59034|

; Then at runtime when we encounter one of those hashes it resolve
; to the correct function, with mutually recursive references
; substituted with the correct hash:reference symbol.

; To resolve a value in the "hash" namespace we look up "resolve:hash"
; in the lexical scope and pass the symbol to it.

